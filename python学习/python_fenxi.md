运行计时：

~~~python
%time 
%timeit(平均时间)
~~~

查看当前会话中的所有变量与函数：

~~~python
%who
%whos	#详细信息
%who_ls	#以列表的形式返回变量与函数
~~~

列出所有魔法指令 : 

~~~python
%lsmagic
~~~

## ***numpy库学习***

***扩展：***  可视化  matplotlib.pyplot 		#pyplot显示画图，数据分析与可视化

​			*plt.imshow() 	该方法将数据生成图片：*

### 一、**创建ndarray**

#任何一张图片(二维图片)的转化成数据三维数组，长，宽，最后一维是颜色

变量名.shape 查看数据 **维数** 等信息	

#### *1.使用np.array()由python list创建* 

创建一维数组：

~~~python
sta1=np.array([5,8,27,78])
~~~

创建二维数组：

~~~python
sta2=np.array([[11,15,24],[26,54,78]]) 
~~~



#### *2.使用np的routines函数创建;*

(1)  np.ones(shape,dtype=None,order=' c ')

~~~python
sta1=np.ones(shape=(3,5,7),dtype=int)
~~~

~~~properties
sta1=np.ones(shape=(3,5,7),dtype=int)
print(sta1)

array([[[1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1]],

       [[1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1]],

       [[1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1]]])
~~~

(2) np.zeros(shape,dtype=float,order=' c ')

~~~python
sta1=np.zeros(shape=(3,4),dtype=float)
sta1
array([[0., 0., 0., 0.],
       [0., 0., 0., 0.],
       [0., 0., 0., 0.]])
~~~



(3) np.full(shape,fill_value,dtype=None,order=' c ') 	# ***fill_value 表示填充值( 自定义 )***

~~~python
sta1=np.full((2,3,4),2019,int)
sta1
array([[[2019, 2019, 2019, 2019],
        [2019, 2019, 2019, 2019],
        [2019, 2019, 2019, 2019]],

       [[2019, 2019, 2019, 2019],
        [2019, 2019, 2019, 2019],
        [2019, 2019, 2019, 2019]]])
~~~



(4) np.eye(N,M=None,k=0,dtype=float)	***# 对角线为1，其他的位置为0***

~~~python
sta1=np.eye(10)
sta1
array([[1., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
       [0., 1., 0., 0., 0., 0., 0., 0., 0., 0.],
       [0., 0., 1., 0., 0., 0., 0., 0., 0., 0.],
       [0., 0., 0., 1., 0., 0., 0., 0., 0., 0.],
       [0., 0., 0., 0., 1., 0., 0., 0., 0., 0.],
       [0., 0., 0., 0., 0., 1., 0., 0., 0., 0.],
       [0., 0., 0., 0., 0., 0., 1., 0., 0., 0.],
       [0., 0., 0., 0., 0., 0., 0., 1., 0., 0.],
       [0., 0., 0., 0., 0., 0., 0., 0., 1., 0.],
       [0., 0., 0., 0., 0., 0., 0., 0., 0., 1.]])
~~~

(5) np.linspace(start,stop,num=X,endpoint=True,retstep=False,dtype=None)

~~~python
#lin=linear 线性。 数据可以用该方法进行平分
sta1=np.linspace(0,100,20)
sta1
array([  0.        ,   5.26315789,  10.52631579,  15.78947368,
        21.05263158,  26.31578947,  31.57894737,  36.84210526,
        42.10526316,  47.36842105,  52.63157895,  57.89473684,
        63.15789474,  68.42105263,  73.68421053,  78.94736842,
        84.21052632,  89.47368421,  94.73684211, 100.        ])
~~~

(6) np.arange([start, ]stop,[step, ]dtype=None)

~~~python
sta1=np.arange(0,100,2)	 # 该方法为左闭右开
sta1
array([ 0,  2,  4,  6,  8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32,
       34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66,
       68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98])

~~~

(7) np.random.randint(low,high=None,size=None,dtype="I")  ***# low, high表示一个范围***

​																							***size表示生成数据的个数***

~~~python
sta1=np.random.randint(0,100,10)
sta1
array([13, 81, 41, 68,  6, 81, 96, 10, 29, 94])
~~~

(8) np.random.randn(d0,d1, ... dn)	#标准正态分布

~~~python
sta1=np.random.randn(100)
sta1
array([-0.15744472, -0.30762295,  0.24244715, -0.14483517,  0.21441704,
        1.61905336,  0.16240627,  2.12093734, -0.87002612, -1.70399243,
       -0.70595111,  0.7969683 ,  0.91796753, -0.06837097,  0.3138167 ,
       -0.72909199,  0.5828363 ,  0.37188347, -0.21361552,  0.1338899 ,
        0.96124054, -1.83348699, -0.35093561, -1.19167736,  0.59138147,
        1.14872416, -0.0633886 , -1.95490516,  1.66045935,  0.87716021,
       -0.02113708,  0.01221442, -0.0313812 , -0.40112772,  0.67855236,
       -0.82489027, -1.30166269,  0.24927071, -0.13514446, -0.05902963,
        0.37146249,  1.21905427, -1.89117144,  1.16058641, -0.91665019,
        0.36943687,  0.8682954 ,  0.41042593,  0.7409935 ,  0.21008649,
        1.06231119,  0.77100375,  1.48545736,  0.09575388, -0.39140374,
       -0.23414921, -0.16017106, -1.61951016,  0.13510884, -1.0651052 ,
       -0.67015539,  0.3721728 , -0.04329477, -0.16538939,  0.76729314,
       -0.36252491, -0.96329726,  0.42679825, -1.13824761,  0.74852564,
       -0.91096774,  0.64663277, -1.70429206, -0.95634534,  0.51687077,
       -1.57045419, -0.24025427, -0.06725613,  0.97486237,  0.21280831,
        0.21292277,  1.03906449,  0.42766926,  0.77357485, -0.07013071,
        0.47216956,  0.18593026, -1.0288386 ,  0.6030963 , -0.33503635,
       -1.45939448,  0.77345852,  0.37609611, -0.93680428, -0.13057173,
       -0.65521367, -0.64517199,  0.46578781,  1.35772216,  0.15257148])
~~~

（9）np.random.normal(loc=x,scale=m,size=l) 	***#正态分布（loc系数值 scale波动值，值越大波动越厉害 size生成数值个数）***

~~~python
sta1=np.random.normal(180,2,50)
sta1
array([180.81971658, 176.7628877 , 178.39585258, 178.37603612,
       177.58138923, 179.83289493, 177.74969334, 182.28921554,
       181.5614103 , 183.24481517, 181.53937474, 178.52507355,
       175.90256003, 181.86927172, 178.51162372, 175.92880266,
       181.23441355, 180.27637461, 181.21313346, 179.73179069,
       176.28547269, 177.24531014, 179.04444308, 180.4128206 ,
       179.04195798, 180.05601437, 181.34235052, 177.51819772,
       180.91209923, 177.72357311, 181.7120904 , 178.82422465,
       179.30219741, 180.76108391, 181.79257126, 179.47373959,
       182.77981215, 179.64157426, 182.38060014, 179.00991314,
       184.10660034, 178.57852836, 180.76511614, 179.59202545,
       179.39919446, 176.82369644, 181.71734064, 182.40544095,
       179.79703204, 181.14588511])
~~~

（10）np.random.random(size=None)	 ***#生成0到1的随机数，左闭右开。可使用随机数生成一张图片***

~~~python
sta1=np.random.random(size=30)
sta1
array([0.6183233 , 0.00406297, 0.54426071, 0.65085729, 0.82642383,
       0.42384395, 0.53504462, 0.66496233, 0.55712989, 0.01614615,
       0.70263234, 0.87957989, 0.65756473, 0.39437011, 0.44643927,
       0.06880048, 0.19805332, 0.29020298, 0.04972129, 0.19755888,
       0.02733634, 0.07619357, 0.69830122, 0.63173581, 0.92133723,
       0.5199786 , 0.5874548 , 0.49653206, 0.76255174, 0.23085691])
~~~

*plt.imshow() 	该方法将数据生成图片：*

~~~python
sta1=np.random.random((500,600,3))
plt.imshow(sta1)
<matplotlib.image.AxesImage at 0x20ea92c0c18>
~~~





### 二 、ndarray 的基本操作

##### 1、索引

~~~python
n=np.random.randint(0,100,(3,4))
n
array([[28, 43, 73, 53],
       [23, 48, 13, 50],
       [93, 98, 69,  0]])
n[0,1]
43
~~~



##### 2、切片

**将数据反转，例如[1,2,3]>>>[3,2,1]   用两个 :: 进行切片**

~~~python
sta1=np.arange(0,10,1)
sta1
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

sta1[::-1]
array([9, 8, 7, 6, 5, 4, 3, 2, 1, 0])
~~~



##### 3、变形

**使用reshape函数，注意参数是一个tuple  ！**

~~~python
sta1=np.arange(0,10,1)
sta1
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
sta1.reshape((5,2))
array([[0, 1],
       [2, 3],
       [4, 5],
       [6, 7],
       [8, 9]])
~~~

可以将多维数据转换成一维数据，便于查看

##### 4、级联	np.concatenate()

<1>、级联的参数是列表：一定要加中括号或小括号

<2>、维度必须相同

<3>、形状相符

<4>【重点】级联的方向默认是shape这个tuple的第一个值所代表的维度方向

<5>、可通过axis参数改变级联的方向

~~~python
sta1=np.random.randint(0,10,size=(5,5))
sta1
array([[6, 5, 7, 0, 3],
       [1, 5, 2, 2, 9],
       [0, 0, 3, 1, 0],
       [1, 4, 9, 0, 6],
       [4, 6, 0, 5, 4]])
 np.concatenate((sta1,sta1),axis=0)   #将sta1和sta1进行级联   
 array([[6, 5, 7, 0, 3],
       [1, 5, 2, 2, 9],
       [0, 0, 3, 1, 0],
       [1, 4, 9, 0, 6],
       [4, 6, 0, 5, 4],
       [6, 5, 7, 0, 3],
       [1, 5, 2, 2, 9],
       [0, 0, 3, 1, 0],
       [1, 4, 9, 0, 6],
       [4, 6, 0, 5, 4]]) 
										# axis默认为0
np.concatenate((sta1,sta1),axis=1)
array([[6, 5, 7, 0, 3, 6, 5, 7, 0, 3],
       [1, 5, 2, 2, 9, 1, 5, 2, 2, 9],
       [0, 0, 3, 1, 0, 0, 0, 3, 1, 0],
       [1, 4, 9, 0, 6, 1, 4, 9, 0, 6],
       [4, 6, 0, 5, 4, 4, 6, 0, 5, 4]])
~~~

水平级联与垂直级联。处理自己，进行维度的变更

np.hstack与np.vstack

 

### 三、***ndarray的矩阵操作***

#### 1、算法运算符：

##### <1>、加减乘除

~~~python
import numpy as np
sta1=np.random.randint(0,10,size=(5,6))
sta1
array([[7, 3, 1, 9, 6, 3],
       [6, 5, 3, 4, 6, 2],
       [9, 4, 9, 6, 3, 9],
       [0, 9, 4, 2, 7, 2],
       [5, 8, 8, 1, 8, 4]])
       
sta1+10		# 加法运算
array([[17, 13, 11, 19, 16, 13],
       [16, 15, 13, 14, 16, 12],
       [19, 14, 19, 16, 13, 19],
       [10, 19, 14, 12, 17, 12],
       [15, 18, 18, 11, 18, 14]])
# 减乘除 同理

~~~

##### <2>、矩阵积  np.dot() 	

**# 积的过程中，两组数据的行和列个数必须相反**

~~~python
sta1=np.random.randint(0,10,size=(3,4))
sta2=np.random.randint(0,7,size=(4,3))
display(sta1,sta2)			# display() 展示数据
array([[6, 9, 1, 9],
       [7, 6, 5, 1],
       [1, 2, 7, 8]])
array([[4, 6, 4],
       [5, 2, 4],
       [1, 3, 3],
       [2, 2, 1]])
np.dot(sta1,sta2)
array([[88, 75, 72],
       [65, 71, 68],
       [37, 47, 41]])
~~~



#### 2.广播机制

【重点】ndarray广播机制的两条规则

<1>为缺失值的维度补1

<2>假定缺失值元素用已有值填充

四、ndarray的排序











## **pandas的数据结构**

### 1、Series				# Series 存放的数据必须是一维数据

#### ***<1> series的创建***

(1)由列表或numpy数组创建   

***#默认索引为0到N-1的整数型索引***

~~~python
import numpy as np
import pandas as pd
from pandas import Series
import matplotlib.pyplot as plt

sta1=np.array([2,4,3,7,8])
sta2=Series(sta1)		# 默认索引
sta2

0    2
1    4
2    3
3    7
4    8
dtype: int32
    
sta2.index=list("abcde")	#使用index 自定义索引
sta2
a    2
b    4
c    3
d    7
e    8
dtype: int32
~~~



（2） 由字典创建

~~~python
sta1=Series({'one':'12','two':'33'})
sta1

one    12
two    33
dtype: object
~~~



~~~python
# 例子
s=np.array([150,150,150,300])
s1=Series(s,index=('语文','数学','英语','理综'))
s1

语文    150
数学    150
英语    150
理综    300
dtype: int32
    
s1=Series({'语文':'150','数学':'150','理综':'300'})
s1
语文    150
数学    150
理综    300
dtype: object
~~~

#### <2>  Serise的索引和切片

（1）、显示索引  loc[参数]

~~~python
sta1=Series(np.random.random(10),index=list('abcdefghij')) #随机生成10个数
sta1.loc['a']	# loc[参数]中的参数必须是index中参数，
#【重点】参数要加''
~~~

显示索引切片：

~~~python
sta1.loc['a':'e']
a    0.677751
b    0.014937
c    0.988800
d    0.527615
e    0.853546
dtype: float64
~~~



 (2)、隐式索引  iloc[参数]

~~~python
sta1=Series(np.random.random(10),index=list('abcdefghij'))
sta1.iloc[0]   # iloc[参数]中的参数必须是index默认索引
~~~

隐式索引：

~~~python
sta1.iloc[0:5]
a    0.677751
b    0.014937
c    0.988800
d    0.527615
e    0.853546
dtype: float64
~~~

#### <3> Series的基本概念

可以把Series看成一个定长的有序字典

***可以通过shape、size、index、values等得到Series的属性***

~~~python
sta1=Series(np.random.random(10),index=list('abcdefghij'))
(10,)
10
Index(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'], dtype='object')
array([0.67775082, 0.01493725, 0.98879961, 0.52761528, 0.85354611,
       0.61362628, 0.64917637, 0.43661355, 0.41511525, 0.45932096])

~~~



***可以通过head()、tail() 快速查看Series对象的的样式***	

~~~python
import pandas as pd
see=pd.read_csv('E:\www.csv',encoding='gbk')
see.head(3)		# 查看数据前三行内容
	姓名	性别	年龄	学历	经验	地点	工资
0	陈二保	男	22岁	中专/技校	2-3年	庐阳	面议
1	许贵生	男	29岁	大专	3-5年	经开	面议
2	陈伟伟	男	26岁	高中	3-5年	庐阳	3000-5000元

see.tail(3)		#查看数据末尾三行内容
	姓名	性别	年龄	学历	经验	地点	工资
2728	祝某人	男	24岁	大专	2-3年	合肥	5000-8000元
2729	栾晓东	男	21岁	大专	1年以内	合肥	面议
2730	路娇	女	23岁	大专	1-2年	蜀山	面议



~~~

### 2、DataFrame

DataFrame是一个【表格型】的数据结构，可以看作是【由Series组成的字典】（公用同一个索引）。DataFrame由按一定顺序排列的多列数据组成。【它既有行索引，也有列索引】

***行索引：index***

***列索引：columns***

***值：values  (numpy的二维数组)***

~~~python
df=DataFrame({'张三':[150,150,150,300],'李四':[0,0,0,0]},
             index=['语文','数学','英语','理综'])
df
	张三	李四
语文	150	0
数学	150	0
英语	150	0
理综	300	0
~~~

#### ***<1>、DataFrame列索引***

**通过类似字典的方式**

~~~python
df=DataFrame({'张三':[150,150,150,300],'李四':[0,0,0,0]},
             index=['语文','数学','英语','理综'])           
df['张三']

 语文    150
数学    150
英语    150
理综    300
Name: 张三, dtype: int64            
~~~

**通过属性方式** 	

~~~python
# 对于DataFrame而言，列名就相当于属性
df=DataFrame({'张三':[150,150,150,300],'李四':[0,0,0,0]},
             index=['语文','数学','英语','理综'])  
 df.张三	
 
语文    150
数学    150
英语    150
理综    300
Name: 张三, dtype: int64
~~~

#### <2>、对行进行索引（检索）

1、使用 .loc[] 加index来进行检索

~~~python
df.loc['语文']
张三    150
李四      0
Name: 语文, dtype: int64

df.loc[['语文','数学']]		# 检索多行
	张三	李四
语文	150	0
数学	150	0
        
~~~



2、对元素索引（检索）的方法

~~~python
df.loc[['语文','数学']]
语文	150	0
数学	150	0

df['张三']['语文']='零'
df

张三	李四
语文	零	0
数学	150	0
英语	150	0
理综	300	0
~~~

<3>、DataFrame的运算

1、DataFrame之间的运算，同Series一样

*在运算中自动对齐不同索引的数据*

*如果索引不对应，则补NaN*

***避免数据在求和过程中出现NaN的出现***：

~~~python
# 例子
sta1=DataFrame(np.random.randint(0,150,size=(4,4)),
               index=['老李','张三','老刘','老马',],
              columns=['语文','数学','英语','python'])
sta2=DataFrame(np.random.randint(0,150,size=(5,4)),
               index=['老李','张三','老刘','老马','王五'],
              columns=['语文','数学','英语','python'])

display(sta1,sta2)

语文	数学	英语	python
老李	120	14	77	47
张三	8	87	103	125
老刘	88	67	73	3
老马	75	125	90	88

语文	数学	英语	python
老李	34	14	85	109
张三	85	0	4	27
老刘	114	112	105	70
老马	71	78	148	50
王五	15	61	54	73

sta1+sta2	# 简单相加会出现如下情况（王五同学所有成绩都变成NaN）
	语文	数学	英语	python
张三	93.0	87.0	107.0	152.0
王五	NaN	NaN	NaN	NaN
老刘	202.0	179.0	178.0	73.0
老李	154.0	28.0	162.0	156.0NaN
老马	146.0	203.0	238.0	138.0

# 解决方案如下:
sta1.add(sta2,fill_value=0) # fill_value=0 如果成绩出现NaN则将其设为0

	语文	数学	英语	python
张三	147.0	162.0	261.0	143.0
王五	145.0	147.0	59.0	40.0
老刘	221.0	78.0	127.0	147.0
老李	161.0	66.0	168.0	263.0
老马	61.0	137.0	95.0	94.0
~~~

2、Series和DataFrame之间的运算

【重点】：<1>、使用python操作符：以行为单位操作（参数必须是行），对所有行都有效。（类似于numpy中二维数组与一维数组的运算，但可能出现NaN）

​				<2>、使用pandas操作函数：

​								axis=0 ：以列为单位操作（参数必须是列），对所有列都有效。

​								axis=1：以行为单位操作（参数必须是行），对所有行都有效。



***pandas处理丢失数据***

【】丢失数据分为两种类型：

​									<1>、None类型：None是python自带，其类型为python object。													因此None不能参与任何计算中

​									<2>、np.nan (NaN)类型：np.nan是浮点类型，能参与到计算												中，但计算结果总是NaN

（1）判断函数： 

​			isnull()  # 判断数据中为空的数据，为空数据返回True，不为空的数据返回False

​			notnull() # 判断数据不为空（ 与isnull() ）相反 

(2) 过滤函数： dropna()  # 可以选择过滤的是***行***，还是***列***。

~~~python
sta1

	语文	数学	英语	python
老李	9	43	64	53.0
张三	39	75	43	NaN
老刘	88	77	147	39.0
老马	84	125	17	NaN
王五	60	129	106	142.0

sta2=sta1.dropna() 	 # dropna() 默认过滤行数据 axis=0 (默认)
sta2
	语文	数学	英语	python
老李	9	43	64	53.0
老刘	88	77	147	39.0
王五	60	129	106	142.0


sta3=sta1.dropna(axis=1)	#过滤列数据 axis=1
sta3
	语文	数学	英语
老李	9	43	64
张三	39	75	43
老刘	88	77	147
老马	84	125	17
王五	60	129	106
~~~





(3) 填充数据Series/Dataframe:

​		***fillna()***

~~~python
sta1
	语文	数学	英语	python
老李	9	43	64	53.0
张三	39	75	43	NaN
老刘	88	77	147	39.0
老马	84	125	17	NaN
王五	60	129	106	142.0

sta2=sta1.fillna(value='php')	# 对所有的空数据进行了替换
sta2
	语文	数学	英语	python
老李	9	43	64	53
张三	39	75	43	php
老刘	88	77	147	39
老马	84	125	17	php
王五	60	129	106	142
~~~



*向后填充*

~~~python
	语文	数学	英语	python
老李	9	43	64	53.0
张三	39	75	43	NaN
老刘	88	77	147	39.0
老马	84	125	17	NaN
王五	60	129	106	142.0

sta2=sta1.fillna(method='backfill')
sta2
	语文	数学	英语	python
老李	9	43	64	53.0
张三	39	75	43	39.0
老刘	88	77	147	39.0
老马	84	125	17	142.0
王五	60	129	106	142.0

~~~



*向前填充*

~~~python
sta2=sta1.fillna(method='ffill')	# f==forward 前面的意思
sta2
	语文	数学	英语	python
老李	9	43	64	53.0
张三	39	75	43	53.0
老刘	88	77	147	39.0
老马	84	125	17	39.0
王五	60	129	106	142.0

~~~



扩展：numpy  中的 ***傅里叶***

第一步读取数据：

~~~python
import numpy as np
# fft 傅里叶转换   ifft 傅里叶反转
from numpy.fft import fft,ifft
from PIL import Image  # 图片处理库

sta1=Image.open('h:pt.jpg')		#读取本地图片
sta1 
~~~



***pandas层次化索引***

1、创建多层次行索引

<1>、隐式构造

​	& Series 也可以创建多层索引

~~~python
import numpy as np
import pandas as pd
from pandas import Series ,DataFrame

sta1=Series([2,4,6,8],index=[['a','a','b','b'],['a','b','c','d']])
sta1
a  a    2
   b    4
b  c    6
   d    8
~~~

​	&  DataFrame 创建多层索引

~~~python
sta1=DataFrame(np.random.randint(0,150,size=(4,2)),
               columns=["语文","数学"],
              index=[['tiger','tiger','elephate','elephate'],
                    ['green','brown','green','brown']])
sta1
		            语文	  数学
tiger	   green	 41	    20
		   brown	117     4
elephate   green      5	    34
		  brown	    127    64

~~~

<2>、显示构造 pd.Multilndex

​	& 使用数组

~~~python
sta1=DataFrame(np.random.randint(0,150,size=(4,2)),
               columns=["语文","数学"],
              index=pd.MultiIndex.from_arrays(
                  [['tiger','tiger','elephate','elephate'],
                    ['green','brown','green','brown']])
sta1
		            语文	  数学
tiger	   green	 41	    20
		   brown	117     4
elephate   green      5	    34
		  brown	    127    64


~~~



​	& 使用typle

​	& 使用product  	（最简单，推荐使用）

~~~python
sta1=DataFrame(np.random.randint(0,150,size=(4,2)),
               columns=["语文","数学"],
              index=pd.MultiIndex.from_product([['tiger','elephate'],['green','brown']]))
sta1
					语文	数学
tiger		green	 36	  110
			brown	146	  79
elephate	green	 27   102
			brown	24	 113


~~~

***&&、对DataFrame列同样可以设置多层索引***

~~~python
sta1=DataFrame(np.random.randint(0,150,size=(2,4)),
               columns=pd.MultiIndex.from_product([['tiger','elephate'],        	['green','brown']]),
index=["语文","数学"])

sta1

		tiger	elephate
 	green	brown	green	brown
语文	54		36	   108		72
数学	79		143	   129		6
~~~



2、多层索引

<1>、索引

~~~python
sta1['tiger','green']

语文    54
数学    79
Name: (tiger, green), dtype: int32

sta1['tiger','green']['语文']
54

~~~



<2>、切片

=============





​													==============================



***pandas数据处理***

1、删除重复元素

​	& 使用  .duplicated()  方法 ***查看***  是否存在重复值

​	& 使用 .drop_duplicated() 方法  ***删除***  重复值。***该方法只能删除行数据***

~~~python
sta1=DataFrame(np.random.randint(0,3,size=(6,2)),
               columns=['语文','数学'],
              index=['小明','小张','张三','小明','李四','张三'])
sta1
	语文	数学
小明	1	2
小张	1	0
张三	2	2
小明	2	1
李四	1	2
张三	0	2

sta1.duplicates()	# 查看是否存在重复值
小明    False
小张    False
张三    False
小明    False
李四     True		# 存在
张三    False
dtype: bool
    
sta1.drop_duplicates()	# 删除存在的重复值	该方法只能对行数据操作
	语文	数学
小明	1	2
小张	1	0
张三	2	2
小明	2	1
张三	0	2

~~~

***&&  如果使用pd.concat() 方法生成新的DataFrame, 新的数据中出现相同值，这时	     	使用duplicate() 和drop_duplicaes()都会出现问题。(问题所在：列明重复)  ***

2、映射



=======================



​																	================================



***3、异常值检测和过滤：***

​		&& 使用describe() 函数查看每一列的描述性统计量

~~~python
sta1=DataFrame(np.random.randint(0,150,size=(6,3)),index=list('abcdef'),
              columns=list('语数外'))

	语	数	外
a	81	41	98
b	143	126	113
c	32	110	4
d	124	95	145
e	115	31	138
f	83	24	138

sta1.describe()
	语	数	外
count	6.000000	6.000000	6.000000	# 表示有六个数
mean	96.333333	71.166667	106.000000	# 平均数
std	39.606397	44.341478	53.077302		# 标准差
min	32.000000	24.000000	4.000000		# 最小值
25%	81.500000	33.500000	101.750000		
50%	99.000000	68.000000	125.500000
75%	121.750000	106.250000	138.000000
max	143.000000	126.000000	145.000000		# 最大值
~~~



​	&& 使用std()函数可以求得DataFrame 对象每一列的标准差

~~~python
sta1=DataFrame(np.random.randint(0,150,size=(6,3)),index=list('abcdef'),
              columns=list('语数外'))
sta1
	语	数	外
a	12	57	42
b	140	7	24
c	130	20	69
d	144	25	14
e	114	3	61
f	43	122	66
 
sta1.std()		# 
语    55.815470
数    44.922155		# 标准差
外    23.143034
dtype: float64
~~~





***4、数据聚合【重点】***

​	数据分类处理：

​		$ 分组：先把数据分成几组

​		$ 用函数处理 ：为不同组的数据应用不同的函数来转换数据

​		$ 合并：把不同组得到的结果合并起来

​	***1、数据分类处理的核心：groupby() 函数***

~~~python
sta1=DataFrame({'item':['苹果','橙子','香蕉','苹果'],'pice':[2,3,2,5],
               'clor':['red','orange','blue','green']})
sta1

	item	pice	clor
0	苹果	2	red
1	橙子	3	orange
2	香蕉	2	blue
3	苹果	5	green

tr=sta1.groupby('item')	# 按照 item 进行 分类	(可对数据进行处理)
tr.groups			   # 查看分类 结果

{'橙子': Int64Index([1], dtype='int64'),
 '苹果': Int64Index([0, 3], dtype='int64'),  # 0,3 分别表示索引
 '香蕉': Int64Index([2], dtype='int64')}

tr['pice'].mean()	# 求平均值 
item
橙子    3.0
苹果    3.5
香蕉    2.0
Name: pice, dtype: float64
~~~

























